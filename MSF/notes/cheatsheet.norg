@document.meta
title: Cheat Sheet
author: João Capucho
@end

Este documento contêm várias fórmulas e bocados de informação utéis.

* Incertezas

  Todas as medições do mundo real contêm uma incerteza associada esta é denotada depois
  do valor medido como $\pm c$ onde $c$ têm a mesma unidade que o valor. Para medições
  diretas o valor da incerteza é normalmente obtido de duas maneiras:

  - Medições com instrumentos analógicas: A incerteza é igual a metade da menor divisão
	da escala.
  - Medições com instrumentos digitais: A incerteza é igual a menor divisão da escala.

  Para medições indiretas (calculadas a partir de outras medições) a incerteza é calculada
  dependendo da operação aplicada, o gráfico seguinte a incerteza para algumas operações.

  @embed image
  assets/Incerteza.png
  @end

  $F$ é uma função qualquer e $\frac{\partial F}{\partial a}$ é a derivada parcial de $F$
  para $a$.

* Derivadas parciais

  A derivada parcial é uma derivada que se aplica a uma função que têm mais de um argumento,
  a derivada parcial utiliza o símbolo $\partial$ em vez de $d$ e é calculada em relação a
  uma variavél em específico, todas as outras variavéis assumem-se como constantes.

  Dada a seguinte função com três argumentos

  @math
  F(a, b, c) = ba + c
  @end

  A sua derivada parcial para $a$ é a seguinte

  @math
  \frac{\partial F}{\partial a} = b
  @end

  Aqui $c$ foi eleminado pois considera-se uma constante, $b$ também é uma constante neste
  caso mas como está a multiplicar por $a$ logo mantêm-se, $a$ calcula-se normalmente.

* Movimento

  O movimento é descrito por três quantidades, a posição, a velocidade a aceleração, estas
  quantidades relacionam-se das seguintes maneiras, onde $t$ é o tempo.

  @embed image
  assets/movimento-relacoes.png
  @end

** Movimento uniforme

   Caso a aceleração seja constante durante o intervalo de tempo em estudo, pode-se calcular
   a posição instantânea utilizando a seguinte fórmula:

   @math
   x(t) = x_0 + v_0t + \frac{1}{2}at^2
   @end

   Onde $x_0$ e $v_0$ são a posição e a velocidade do corpo no instante inicial respetivamente,
   e $a$ é a aceleração.

   A velocidade pode ser obtida diretamente através da seguinte fórmula:

   @math
   v(t) = v_0 + at
   @end

** Queda livre sem resistência do ar

   A queda livre sem resistência do ar, é um caso especial do movimento uniforme onde a
   aceleração corresponde a aceleração gravitíca do planeta em questão ($g = 9.8$ na terra).

   @math
   \begin{align*}
   a(t) &= g \\
   v(t) &= v_0t + gt \\
   x(t) &= x_0 + v_0t + \frac{1}{2}gt^2
   \end{align*}
   @end

   CUIDADO: $g = 9.8$ assume que a posição aumenta em direção ao planeta (ou seja o eixo da
   posição está invertido face ao normalmente utilizado).

** Queda livre com resistência do ar

   A queda livre com resistência do ar não é um movimento uniforme pois a aceleração varia
   com a velocidade do corpo, pois esta causa atrito com o ar. A aceleração é dada pela
   seguinte fórmula:

   @math
   a(t) = g - \frac{g}{v_T^2} v \lvert v \rvert
   @end

   Onde $v_T$ é a velocidade terminal do corpo e $v$ é a velocidade instantânea do corpo
   em $t$. A posição instantânea é dada pela seguinte expressão:

   @math
   y(t) = \frac{v_T^2}{g} \ln \left[ \cosh \left( \frac{gt}{v_T} \right) \right]
   @end

   CUIDADO: Ambas estas expressões assumem que $g$ é positivo e que a posição aumenta
   em direção ao planeta (ou seja o eixo da posição está invertido face ao normalmente
   utilizado), para utilizar um eixo de posição que aumenta a medida que o corpo se
   afasta da superfície do planeta, basta negarmos o $g$ na aceleração ($g$ continua
   positivo).

   @math
   a(t) = -g - \frac{g}{v_T^2} v \lvert v \rvert
   @end

* Integração de Euler

  @math
  \begin{align*}
  &v_x(t + \delta t) \approx v(t) + a_x(t) \times \delta t \\
  &x(t + \delta t) \approx x(t) + v_x(t) \times \delta t
  \end{align*}
  @end

  @code python
  # Parâmetros
  dt = 0.01 # δt - tamanho do passo
  t0 = 0 # Tempo inicial
  tf = 4.0 # Tempo final
  y0 = 0 # Posição inicial
  vy0 = 0 # Velocidade inicial
  g = 9.8 # Aceleração gravítica

  # Número de passos/iterações
  #
  # + 0.1 para garantir que não há arrendodamentos
  # para baixo
  n = int((tf-t0) / dt + 0.1)

  t = np.zeros(n + 1) # Tempo
  y = np.zeros(n + 1) # Posição
  vy = np.zeros(n + 1) # Velocidade
  ay = np.zeros(n + 1) # Aceleração

  # Valores inicias
  vy[0] = vy0
  t[0] = t0
  y[0] = y0

  for i in range(n):
	  ay[i] = g 

	  vy[i + 1] = vy[i] + ay[i] * dt
	  y[i + 1] = y[i] + vy[i] * dt 
	  t[i + 1] = t[i] + dt
  @end

** Integração de Euler-Cromer

   Melhor para movimentos periódicos como órbitas e molas (conserva a energia).

   @math
   \begin{align*}
   &v_x(t + \delta t) \approx v(t) + a_x(t) \times \delta t \\
   &\boldsymbol{ x(t + \delta t) \approx x(t) + v_x(t + \delta t) \times \delta t }
   \end{align*}
   @end

   @code python
   # Parâmetros
   dt = 0.01 # δt - tamanho do passo
   t0 = 0 # Tempo inicial
   tf = 4.0 # Tempo final
   y0 = 0 # Posição inicial
   vy0 = 0 # Velocidade inicial
   g = 9.8 # Aceleração gravítica

   # Número de passos/iterações
   #
   # + 0.1 para garantir que não há arrendodamentos
   # para baixo
   n = int((tf-t0) / dt + 0.1)

   t = np.zeros(n + 1) # Tempo
   y = np.zeros(n + 1) # Posição
   vy = np.zeros(n + 1) # Velocidade
   ay = np.zeros(n + 1) # Aceleração

   # Valores inicias
   vy[0] = vy0
   t[0] = t0
   y[0] = y0

   for i in range(n):
	   ay[i] = g 

	   vy[i + 1] = vy[i] + ay[i] * dt
	   y[i + 1] = y[i] + vy[i + 1] * dt 
	   t[i + 1] = t[i] + dt
   @end

** Integração de Euler multidimensional

   @code python
   # Parâmetros
   dt = 0.001 # δt - tamanho do passo
   t0 = 0 # Tempo inicial
   tf = 1 # Tempo final
   x0 = np.array([0, 0, 23.8]) # Posição inicial
   v0 = np.array([25, 5, -50]) # Velocidade inicial

   # Número de passos/iterações
   #
   # + 0.1 para garantir que não há arrendondamentos
   # para baixo
   n = int((tf-t0) / dt + 0.1)
   # Arrays de arrays tridimensionais
   shape = (n + 1, 3)

   t = np.zeros(n + 1) # Tempo
   x = np.zeros(shape) # Posição
   v = np.zeros(shape) # Velocidade
   a = np.zeros(shape) # Aceleração

   # Valores iniciais
   a[0] = np.array([0, -9.8, 0])
   v[0] = v0
   t[0] = t0
   x[0] = x0

   for i in range(n):
	   a[i + 1] = np.array([0, -9.8, 0])

	   v[i + 1] = v[i] + a[i] * dt
	   x[i + 1] = x[i] + v[i] * dt
	   t[i + 1] = t[i] + dt
   @end

** Obter um valor num dado instante

   @code python
   target = 3
   targetIdx = int(np.ceil(target / dt))

   v = vy[targetIdx]
   @end

** Obter um máximo e o instante onde ocorreu

   @code python
   idx = y.argmax()
   yMax = y[idx]
   tMax = t[idx]
   @end

** Obter o primeiro zero e o instante onde ocorreu

   @code python
   for i in range(n):
     if y[i] == 0 or y[i] * y[i + 1] < 0:
       idx = i
       break

   yZero = y[idx]
   tZero = t[idx]
   @end

** Erros

   - Erro de truncatura local: proporcional a $\delta t^2$
   - Erro de truncatura global: proporcional a
	 $N\delta t^2 = \left( t_f - t_0 \right) \delta t$, onde $N$ é o número de passos.
